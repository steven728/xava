/**
 * The MIT License
 * 
 * Copyright (c) 2016-2018 Shell Technologies PTY LTD
 *
 * You may obtain a copy of the License at
 * 
 *       http://mit-license.org/
 *       
 */
package io.roxa.xava.vertx;

import java.util.List;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.json.JsonArray;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.ResultSet;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.sql.UpdateResult;

/**
 * @author Steven Chen
 *
 */
public class JdbcExecutor {

	private static final Logger logger = LoggerFactory.getLogger(JdbcExecutor.class);

	private JDBCClient jdbcClient;

	/**
	 * To create a new JdbcExecutor that wrap the JDBCClient and provides the
	 * convenience operations
	 * 
	 * @param jdbcClient - A JDBCClient
	 */
	public JdbcExecutor(JDBCClient jdbcClient) {
		this.jdbcClient = jdbcClient;
	}

	/**
	 * This method accepts a SQL callback operation. the connection will auto close
	 * by this method.
	 * 
	 * @param execHandler - callback
	 * @return
	 */
	public <T> Future<T> exec(Function<SQLConnection, Future<T>> execHandler) {
		Future<T> future = Future.future();
		jdbcClient.getConnection(pendingConn -> {
			if (pendingConn.succeeded()) {
				SQLConnection conn = pendingConn.result();
				execHandler.apply(conn).setHandler(pendingResult -> {
					conn.close(closeHandler());
					if (pendingResult.succeeded()) {
						future.complete(pendingResult.result());
					} else {
						future.fail(pendingResult.cause());
					}
				});
			} else {
				future.fail(pendingConn.cause());
			}
		});
		return future;
	}

	/**
	 * The method will set auto commit with false and close the connection when SQL
	 * operation completed.
	 * 
	 * @param execHandler - callback
	 * @return
	 */
	public <T> Future<T> execTx(Function<SQLConnection, Future<T>> execHandler) {
		Future<T> future = Future.future();
		jdbcClient.getConnection(pendingConn -> {
			if (pendingConn.succeeded()) {
				SQLConnection conn = pendingConn.result();
				conn.setAutoCommit(false, tx -> {
					if (tx.succeeded()) {
						execHandler.apply(conn).setHandler(pendingResult -> {
							conn.close(closeHandler());
							if (pendingResult.succeeded()) {
								conn.commit(commitHandler(future, pendingResult));
							} else {
								conn.rollback(rollbackHandler());
								future.fail(pendingResult.cause());
							}
						});
					} else {
						conn.close(closeHandler());
						future.fail(tx.cause());
					}
				});
			} else {
				future.fail(pendingConn.cause());
			}
		});
		return future;
	}

	/**
	 * To execute a callable statement for SQL procedures. A JsonArray containing
	 * the parameter values and finally a JsonArray containing the output types
	 * e.g.: [null, 'VARCHAR'].
	 * <p>
	 * <code>
	 * String proc = "{ call customer_lastname(?, ?) }";
	 * executor.call(proc,new JsonArray().add("ABC"), new JsonArray().addNull().add("VARCHAR"),res -> {
	 * if (res.succeeded()) {
	 *  ResultSet result = res.result();
	 * } else {
	 *   
	 * }
	 * });
	 * </code>
	 * </p>
	 * 
	 * @param procStatement - standard JDBC format { call func_proc_name() }
	 * @param in            - the IN parameters
	 * @param out           - the OUT parameters
	 * @return
	 */
	public Future<List<JsonArray>> call(String procStatement, JsonArray in, JsonArray out) {
		return exec(conn -> {
			Future<List<JsonArray>> future = Future.future();
			conn.callWithParams(procStatement, in, out, queryResutlHandler(future));
			return future;
		});

	}

	/**
	 * To execute a callable statement for SQL functions
	 * 
	 * @param funcStatement - standard JDBC format { call func_proc_name() }
	 * @return - A SQL function returns some output using the return keyword
	 */
	public Future<List<JsonArray>> call(String funcStatement) {
		return exec(conn -> {
			Future<List<JsonArray>> future = Future.future();
			conn.call(funcStatement, queryResutlHandler(future));
			return future;
		});
	}

	/**
	 * The method can use within exec or execTx method. It will return the auto
	 * generated key column. Using this method can combines other operation in same
	 * connection.
	 * 
	 * @param conn        - A SQL connection
	 * @param sql         - A SQL statment text
	 * @param params      - A parameter array
	 * @param autoKeyName - The column name of auto generated key
	 * @return
	 */
	public Future<JsonArray> update(SQLConnection conn, String sql, JsonArray params, String autoKeyName) {
		Future<JsonArray> future = Future.future();
		conn.setOptions(new SQLOptions().setAutoGeneratedKeys(true)
				.setAutoGeneratedKeysIndexes(new JsonArray().add(autoKeyName)));
		if (params != null && !params.isEmpty()) {
			conn.updateWithParams(sql, params, updateResultHandlerWithAutoKey(future));
		} else {
			conn.update(sql, updateResultHandlerWithAutoKey(future));
		}
		return future;
	}

	/**
	 * The method can use within exec or execTx method to complete the update
	 * operation. Using this method can combines other operation in same connection.
	 * 
	 * @param conn   - A SQL connection
	 * @param sql    - A SQL statment text
	 * @param params - A parameter array
	 * @return
	 */
	public Future<Integer> update(SQLConnection conn, String sql, JsonArray params) {
		Future<Integer> future = Future.future();
		if (params != null && !params.isEmpty()) {
			conn.updateWithParams(sql, params, updateResultHandler(future));
		} else {
			conn.update(sql, updateResultHandler(future));
		}
		return future;
	}

	/**
	 * The method can use within exec or execTx method to complete the query
	 * operation. Using this method can combines other operation in same connection.
	 * 
	 * @param conn   - A SQL connection
	 * @param sql    - A SQL statment text
	 * @param params - A parameter array
	 * @return
	 */
	public Future<List<JsonArray>> query(SQLConnection conn, String sql, JsonArray params) {
		Future<List<JsonArray>> future = Future.future();
		if (params != null && !params.isEmpty())
			conn.queryWithParams(sql, params, queryResutlHandler(future));
		else
			conn.query(sql, queryResutlHandler(future));
		return future;
	}

	/**
	 * The method can use within exec or execTx method to complete the batch
	 * operation. Using this method can combines other operation in same connection.
	 * 
	 * @param conn       - A SQL connection
	 * @param sql        - A SQL statment text
	 * @param paramsList - A batch parameters
	 * @return
	 */
	public Future<List<Integer>> batch(SQLConnection conn, String sql, List<JsonArray> paramsList) {
		Future<List<Integer>> future = Future.future();
		conn.batchWithParams(sql, paramsList, batchResultHandler(future));
		return future;
	}

	/**
	 * The method will open and close connection automatically
	 * 
	 * @param sql        - A SQL statment text
	 * @param paramsList - A batch parameters
	 * @return
	 */
	public Future<List<Integer>> batch(String sql, List<JsonArray> paramsList) {
		return exec(conn -> batch(conn, sql, paramsList));
	}

	/**
	 * The method will open and close connection automatically
	 * 
	 * @param sql    - A SQL statment text
	 * @param params - A parameter array
	 * @return
	 */
	public Future<Integer> update(String sql, JsonArray params) {
		return exec(conn -> update(conn, sql, params));
	}

	/**
	 * The method will open and close connection automatically. It will return the
	 * auto generated key column
	 * 
	 * @param sql         - A SQL statment text
	 * @param params      - A parameter array
	 * @param autoKeyName - The column name of auto generated key
	 * @return
	 */
	public Future<JsonArray> update(String sql, JsonArray params, String autoKeyName) {
		return exec(conn -> update(conn, sql, params, autoKeyName));
	}

	/**
	 * The method will open and close connection automatically
	 * 
	 * @param sql    - A SQL statment text
	 * @param params - A parameter array
	 * @return
	 */
	public Future<List<JsonArray>> query(String sql, JsonArray params) {
		return exec(conn -> query(conn, sql, params));
	}

	private Handler<AsyncResult<List<Integer>>> batchResultHandler(Future<List<Integer>> future) {
		return pendingBatchResult -> {
			if (pendingBatchResult.succeeded()) {
				future.complete(pendingBatchResult.result());
			} else {
				future.fail(pendingBatchResult.cause());
			}
		};
	}

	private static Handler<AsyncResult<UpdateResult>> updateResultHandler(Future<Integer> future) {
		return pendingUpdateResult -> {
			if (pendingUpdateResult.succeeded()) {
				UpdateResult updateResult = pendingUpdateResult.result();
				future.complete(updateResult.getUpdated());
			} else {
				future.fail(pendingUpdateResult.cause());
			}
		};
	}

	private static Handler<AsyncResult<UpdateResult>> updateResultHandlerWithAutoKey(Future<JsonArray> future) {
		return pendingUpdateResult -> {
			if (pendingUpdateResult.succeeded()) {
				UpdateResult updateResult = pendingUpdateResult.result();
				future.complete(updateResult.getKeys());
			} else {
				future.fail(pendingUpdateResult.cause());
			}
		};
	}

	private static Handler<AsyncResult<ResultSet>> queryResutlHandler(Future<List<JsonArray>> future) {
		return pendingResultSet -> {
			if (pendingResultSet.succeeded()) {
				ResultSet resultSet = pendingResultSet.result();
				future.complete(resultSet.getResults());
			} else {
				future.fail(pendingResultSet.cause());
			}
		};
	}

	private static <T> Handler<AsyncResult<Void>> commitHandler(Future<T> future, AsyncResult<T> pendingResult) {
		return (pendingCommit) -> {
			if (pendingCommit.succeeded()) {
				logger.info("SQL commit succeeded.");
				future.complete(pendingResult.result());
			} else {
				logger.error("SQL commit failed. cause:", pendingResult.cause());
				future.fail(pendingResult.cause());
			}
		};
	}

	private static Handler<AsyncResult<Void>> rollbackHandler() {
		return pendingRollback -> {
			if (pendingRollback.failed())
				logger.error(pendingRollback.cause().getMessage(), pendingRollback.cause());
			else
				logger.info("SQL rollback.");
		};
	}

	private static Handler<AsyncResult<Void>> closeHandler() {
		return done -> {
			if (done.failed())
				logger.error(done.cause().getMessage(), done.cause());
			else
				logger.info("SQL Connection closed.");
		};
	}

}
